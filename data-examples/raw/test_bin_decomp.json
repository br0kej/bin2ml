{
  "entry.init0": {
    "annotations": [],
    "code": "\nvoid entry.init0(void)\n\n{\n    if (((sym..bss + -0x4010 >> 3) - (sym..bss + -0x4010 >> 0x3f) >> 1 != 0) && (*0x3ff0 != NULL)) {\n    // WARNING: Could not recover jumptable at 0x000010f0. Too many branches\n    // WARNING: Treating indirect jump as call\n        (**0x3ff0)();\n        return;\n    }\n    return;\n}\n"
  },
  "entry0": {
    "annotations": [],
    "code": "\nvoid entry0(ulong param_1, ulong param_2, ulong param_3)\n\n{\n    ulong in_stack_00000000;\n    uchar *apuStack_18 [2];\n    uchar auStack_8 [8];\n    \n    apuStack_18[1] = &stack0xfffffffffffffff8;\n    *(*0x20 + -0x18) = 0x108e;\n    (**0x3fe0)(main, in_stack_00000000, &stack0x00000008, sym.__libc_csu_init, sym.__libc_csu_fini, param_3);\n    do {\n    // WARNING: Do nothing block with infinite loop\n    } while( true );\n}\n"
  },
  "loc.imp._ITM_deregisterTMCloneTable": {
    "annotations": [],
    "code": "\n// WARNING: Control flow encountered bad instruction data\n\nvoid loc.imp._ITM_deregisterTMCloneTable(ulong param_1, char *param_2, ulong param_3, char *param_4)\n\n{\n    unkbyte3 Var1;\n    uint32_t uVar2;\n    uint8_t uVar3;\n    uint8_t uVar4;\n    char cVar5;\n    char cVar6;\n    uint32_t uVar7;\n    uint8_t *puVar8;\n    int32_t *piVar9;\n    char *pcVar10;\n    int32_t *in_RAX;\n    char unaff_BL;\n    char unaff_BH;\n    unkbyte6 unaff_0000001a;\n    int64_t unaff_RBP;\n    uchar in_ZF;\n    char in_SF;\n    char in_OF;\n    \n    // [30] ---- section size 282 named .shstrtab\n    if (in_ZF || in_OF != in_SF) {\n    // WARNING: Bad instruction - Truncating control flow here\n        halt_baddata();\n    }\n    uVar3 = in_RAX;\n    *in_RAX = *in_RAX + uVar3;\n    *in_RAX = *in_RAX + uVar3;\n    *in_RAX = *in_RAX + uVar3;\n    *in_RAX = *in_RAX + uVar3;\n    *in_RAX = *in_RAX + uVar3;\n    *in_RAX = *in_RAX + uVar3;\n    *in_RAX = *in_RAX + uVar3;\n    *in_RAX = *in_RAX + uVar3;\n    *in_RAX = *in_RAX + uVar3;\n    *in_RAX = *in_RAX + uVar3;\n    *in_RAX = *in_RAX + uVar3;\n    *in_RAX = *in_RAX + uVar3;\n    *in_RAX = *in_RAX + uVar3;\n    *in_RAX = *in_RAX + uVar3;\n    *in_RAX = *in_RAX + uVar3;\n    *in_RAX = *in_RAX + uVar3;\n    *in_RAX = *in_RAX + uVar3;\n    *in_RAX = *in_RAX | uVar3;\n    *in_RAX = *in_RAX + uVar3;\n    *in_RAX = *in_RAX + uVar3;\n    *in_RAX = *in_RAX + uVar3;\n    uVar7 = in_RAX + *in_RAX;\n    *uVar7 = *uVar7 + uVar7;\n    puVar8 = uVar7;\n    uVar3 = *puVar8;\n    uVar4 = uVar7;\n    *puVar8 = *puVar8 + uVar4;\n    *CONCAT62(unaff_0000001a, CONCAT11(unaff_BH, unaff_BL)) =\n         (*CONCAT62(unaff_0000001a, CONCAT11(unaff_BH, unaff_BL)) - uVar4) - CARRY1(uVar3, uVar4);\n    *puVar8 = *puVar8 + uVar4;\n    *puVar8 = *puVar8 + uVar4;\n    uVar3 = *puVar8;\n    *puVar8 = *puVar8 + uVar4;\n    *CONCAT62(unaff_0000001a, CONCAT11(unaff_BH, unaff_BL)) =\n         (*CONCAT62(unaff_0000001a, CONCAT11(unaff_BH, unaff_BL)) - uVar4) - CARRY1(uVar3, uVar4);\n    *puVar8 = *puVar8 + uVar4;\n    *puVar8 = *puVar8 + uVar4;\n    uVar3 = *puVar8;\n    *puVar8 = *puVar8 + uVar4;\n    *CONCAT62(unaff_0000001a, CONCAT11(unaff_BH, unaff_BL)) =\n         (*CONCAT62(unaff_0000001a, CONCAT11(unaff_BH, unaff_BL)) - uVar4) - CARRY1(uVar3, uVar4);\n    *puVar8 = *puVar8 + uVar4;\n    *puVar8 = *puVar8 + uVar4;\n    uVar3 = *puVar8;\n    *puVar8 = *puVar8 + uVar4;\n    Var1 = uVar7 >> 8;\n    uVar4 = (uVar4 + '\\0') - CARRY1(uVar3, uVar4);\n    puVar8 = CONCAT31(Var1, uVar4);\n    *puVar8 = *puVar8 + uVar4;\n    *puVar8 = *puVar8 + uVar4;\n    uVar3 = *puVar8;\n    *puVar8 = *puVar8 + uVar4;\n    uVar4 = (uVar4 + '\\0') - CARRY1(uVar3, uVar4);\n    uVar2 = CONCAT31(Var1, uVar4);\n    piVar9 = uVar2;\n    *piVar9 = *piVar9 + uVar4;\n    *piVar9 = *piVar9 + uVar4;\n    *piVar9 = *piVar9 + uVar4;\n    *piVar9 = *piVar9 + uVar2;\n    *piVar9 = *piVar9 + uVar4;\n    *piVar9 = *piVar9 + uVar4;\n    *piVar9 = *piVar9 + uVar4;\n    *piVar9 = *piVar9 + uVar2;\n    *piVar9 = *piVar9 + uVar4;\n    uVar2 = CONCAT31(Var1, uVar4);\n    piVar9 = uVar2;\n    *piVar9 = *piVar9 + uVar4;\n    *piVar9 = *piVar9 + uVar4;\n    *piVar9 = *piVar9 + uVar4;\n    *piVar9 = *piVar9 + uVar4;\n    *piVar9 = *piVar9 + uVar4;\n    *piVar9 = *piVar9 + uVar4;\n    *piVar9 = *piVar9 + uVar4;\n    *piVar9 = *piVar9 + uVar4;\n    *piVar9 = *piVar9 + uVar4;\n    *piVar9 = *piVar9 + uVar4;\n    *piVar9 = *piVar9 + uVar4;\n    *piVar9 = *piVar9 + uVar4;\n    *piVar9 = *piVar9 + uVar4;\n    *param_2 = *param_2 + uVar4;\n    *piVar9 = *piVar9 + uVar4;\n    *piVar9 = *piVar9 + uVar4;\n    *piVar9 = *piVar9 + uVar4;\n    *param_2 = *param_2 + uVar4;\n    *piVar9 = *piVar9 + uVar4;\n    *piVar9 = *piVar9 + uVar4;\n    *piVar9 = *piVar9 + uVar4;\n    *piVar9 = *piVar9 + param_3;\n    *piVar9 = *piVar9 + uVar4;\n    *piVar9 = *piVar9 + uVar4;\n    *piVar9 = *piVar9 + uVar4;\n    *piVar9 = *piVar9 + uVar2;\n    *piVar9 = *piVar9 + uVar4;\n    piVar9 = uVar2;\n    *piVar9 = *piVar9 + uVar4;\n    *piVar9 = *piVar9 + uVar4;\n    *piVar9 = *piVar9 + uVar4;\n    uVar3 = *piVar9;\n    *piVar9 = *piVar9 + uVar4;\n    *piVar9 = *piVar9 + uVar4 + CARRY1(uVar3, uVar4);\n    *piVar9 = *piVar9 + uVar4;\n    *piVar9 = *piVar9 + uVar4;\n    uVar3 = *piVar9;\n    *piVar9 = *piVar9 + uVar4;\n    *piVar9 = *piVar9 + uVar4 + CARRY1(uVar3, uVar4);\n    *piVar9 = *piVar9 + uVar4;\n    *piVar9 = *piVar9 + uVar4;\n    *(unaff_RBP + 2) = *(unaff_RBP + 2) + (param_3 >> 8);\n    *piVar9 = *piVar9 + uVar4;\n    *piVar9 = *piVar9 + uVar4;\n    *piVar9 = *piVar9 + uVar4;\n    if (*piVar9 == 0) {\n        *piVar9 = *piVar9 + uVar4;\n    }\n    *piVar9 = *piVar9 + uVar4;\n    *piVar9 = *piVar9 + uVar4;\n    *piVar9 = *piVar9 + param_3;\n    *piVar9 = *piVar9 + uVar4;\n    *piVar9 = *piVar9 + uVar4;\n    *piVar9 = *piVar9 + uVar4;\n    *piVar9 = *piVar9 + uVar2;\n    *piVar9 = *piVar9 + uVar4;\n    pcVar10 = CONCAT31(Var1, uVar4);\n    *pcVar10 = *pcVar10 + uVar4;\n    cVar6 = uVar7 >> 8;\n    *pcVar10 = *pcVar10 + cVar6;\n    *pcVar10 = *pcVar10 + uVar4;\n    *pcVar10 = *pcVar10 + uVar4;\n    *pcVar10 = *pcVar10 + uVar4;\n    *pcVar10 = *pcVar10 + cVar6;\n    *pcVar10 = *pcVar10 + uVar4;\n    *pcVar10 = *pcVar10 + uVar4;\n    *pcVar10 = *pcVar10 + uVar4;\n    *pcVar10 = *pcVar10 + cVar6;\n    *pcVar10 = *pcVar10 + uVar4;\n    *pcVar10 = *pcVar10 + uVar4;\n    *pcVar10 = *pcVar10 + uVar4;\n    *0x1 = *0x1 + '\\x01';\n    pcVar10 = 0x2;\n    cVar6 = *pcVar10;\n    cVar6 = *pcVar10;\n    *pcVar10 = *pcVar10 + unaff_BH;\n    cVar6 = *pcVar10;\n    cVar6 = *pcVar10;\n    cVar6 = *pcVar10;\n    uVar3 = *0x1 + '\\x01';\n    uVar4 = 1;\n    cVar5 = '\\x01';\n    *0x1 = uVar3 + uVar4 + uVar4 + CARRY1(uVar3, uVar4) + uVar4 + cVar5;\n    *param_4 = *param_4 + cVar5;\n    *0x1 = *0x1 + cVar5;\n    *param_2 = *param_2 + cVar5;\n    *0x1 = *0x1 + cVar5;\n    pcVar10 = 0x2e;\n    cVar6 = *pcVar10;\n    cVar6 = *pcVar10;\n    *pcVar10 = *pcVar10 + unaff_BH;\n    cVar6 = *pcVar10;\n    cVar6 = *pcVar10;\n    cVar6 = *pcVar10;\n    *0x1 = *0x1 + cVar5;\n    pcVar10 = 0x3e;\n    cVar6 = *pcVar10;\n    cVar6 = *pcVar10;\n    *pcVar10 = *pcVar10 + unaff_BH;\n    cVar6 = *pcVar10;\n    cVar6 = *pcVar10;\n    cVar6 = *pcVar10;\n    *0x1 = *0x1 + cVar5;\n    pcVar10 = 0x3e;\n    cVar6 = *pcVar10;\n    cVar6 = *pcVar10;\n    *pcVar10 = *pcVar10 + unaff_BH;\n    cVar6 = *pcVar10;\n    cVar6 = *pcVar10;\n    cVar6 = *pcVar10;\n    *0x1 = *0x1 + cVar5;\n    pcVar10 = 0x3;\n    cVar6 = *pcVar10;\n    cVar6 = *pcVar10;\n    *pcVar10 = *pcVar10 + unaff_BL;\n    cVar6 = *pcVar10;\n    cVar6 = *pcVar10;\n    cVar6 = *pcVar10;\n    cVar6 = '\\x01';\n    *0x1 = *0x1 + cVar6 + cVar6 + cVar6;\n    // WARNING: Bad instruction - Truncating control flow here\n    halt_baddata();\n}\n"
  },
  "main": {
    "annotations": [],
    "code": "\nulong main(void)\n\n{\n    uchar *puVar1;\n    ulong uStack_20;\n    uchar auStack_18 [8];\n    int32_t iStack_10;\n    int32_t iStack_c;\n    \n    *(*0x20 + -0x20) = 0x1166;\n    sym.imp.printf(\"This is a very silly program!\");\n    iStack_10 = 0;\n    if (0 == 1) {\n        *(&stack0xffffffffffffffe8 + -8) = 0x1197;\n        sym.imp.printf(\"Hello, World!\");\n        puVar1 = &stack0xffffffffffffffe8;\n    }\n    else {\n        *(&stack0xffffffffffffffe8 + -8) = 0x1184;\n        sym.imp.printf(\"Not one!\");\n        puVar1 = &stack0xffffffffffffffe8 + 0;\n    }\n    iStack_c = iStack_10 + 1;\n    if (iStack_c == 0) {\n        if (iStack_c == 10) {\n            *(puVar1 + -8) = 0x11d0;\n            sym.imp.printf(\"Unreachable silly\");\n        }\n        else {\n            *(puVar1 + -8) = 0x11e3;\n            sym.imp.printf(\"Even more unreachable!\");\n        }\n    }\n    else {\n        *(puVar1 + -8) = 0x11b7;\n        sym.imp.printf(\"Not zero!\");\n    }\n    return 0;\n}\n"
  },
  "sym..plt.got": {
    "annotations": [],
    "code": "\nvoid sym..plt.got(void)\n\n{\n    // WARNING: Could not recover jumptable at 0x00001044. Too many branches\n    // WARNING: Treating indirect jump as call\n    (**0x3ff8)();\n    return;\n}\n"
  },
  "sym.__do_global_dtors_aux": {
    "annotations": [],
    "code": "\nvoid sym.__do_global_dtors_aux(void)\n\n{\n    uchar *puVar1;\n    \n    if (sym..bss + '\\0' == '\\0') {\n        puVar1 = &stack0xfffffffffffffff8;\n        if (*0x3ff8 + 0 != 0) {\n            sym..plt.got(_obj.__dso_handle);\n            puVar1 = &stack0x00000000 + -8;\n        }\n        *(puVar1 + -8) = 0x112c;\n        sym.deregister_tm_clones();\n        sym..bss = 0x1;\n        return;\n    }\n    return;\n}\n"
  },
  "sym.__libc_csu_fini": {
    "annotations": [],
    "code": "\nvoid sym.__libc_csu_fini(void)\n\n{\n    return;\n}\n"
  },
  "sym.__libc_csu_init": {
    "annotations": [],
    "code": "\nvoid sym.__libc_csu_init(uint param_1, ulong param_2, ulong param_3)\n\n{\n    code *pcVar1;\n    int64_t iVar2;\n    uchar *puVar3;\n    uint8_t uVar4;\n    uchar auStack_38 [8];\n    \n    uVar4 = &stack0x00000000 == 0x38;\n    sym._init();\n    puVar3 = &stack0xffffffffffffffc8;\n    if (!(!true & uVar4 | (true && sym..fini_array + -0x3db8 >> 3 == 0))) {\n        iVar2 = 0;\n        do {\n            pcVar1 = *(segment.LOAD3 + iVar2 * 8);\n            *(puVar3 + -8) = 0x123d;\n            (*pcVar1)(param_1, param_2, param_3);\n            puVar3 = puVar3;\n            iVar2 = iVar2 + 1;\n        } while (sym..fini_array + -0x3db8 >> 3 != iVar2);\n    }\n    return;\n}\n"
  },
  "sym._fini": {
    "annotations": [],
    "code": "\nvoid sym._fini(void)\n\n{\n    return;\n}\n"
  },
  "sym._init": {
    "annotations": [],
    "code": "\nvoid sym._init(void)\n\n{\n    ulong auStack_10 [2];\n    \n    if (*0x3fe8 != NULL) {\n        *(*0x20 + -8 + -8) = 0x1016;\n        (**0x3fe8)();\n    }\n    return;\n}\n"
  },
  "sym.deregister_tm_clones": {
    "annotations": [],
    "code": "\nvoid sym.deregister_tm_clones(void)\n\n{\n    if ((false) && (*0x3fd8 != NULL)) {\n    // WARNING: Could not recover jumptable at 0x000010af. Too many branches\n    // WARNING: Treating indirect jump as call\n        (**0x3fd8)();\n        return;\n    }\n    return;\n}\n"
  },
  "sym.imp.printf": {
    "annotations": [],
    "code": "\nvoid sym.imp.printf(void)\n\n{\n    // WARNING: Could not recover jumptable at 0x00001054. Too many branches\n    // WARNING: Treating indirect jump as call\n    (**0x3fd0)();\n    return;\n}\n"
  },
  "sym.register_tm_clones": {
    "annotations": [],
    "code": "\nvoid sym.register_tm_clones(void)\n\n{\n    if (((sym..bss + -0x4010 >> 3) - (sym..bss + -0x4010 >> 0x3f) >> 1 != 0) && (*0x3ff0 != NULL)) {\n    // WARNING: Could not recover jumptable at 0x000010f0. Too many branches\n    // WARNING: Treating indirect jump as call\n        (**0x3ff0)();\n        return;\n    }\n    return;\n}\n"
  }
}